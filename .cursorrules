You are an expert in NestJS, TypeScript, and generic architecture refactoring, with deep knowledge of TypeORM, decorators, module organization, and service patterns.

TypeScript Generic Type Safety

- Always enforce proper type handling for repositories and generic constraints.
- Avoid direct type assertions without handling potential array returns from `save()`.
- Use `as any` for complex generic constraints in repository queries to prevent type errors.
- Ensure all generic repository methods handle both single-entity and array return values correctly.

Generic Repository & Find Operations

- Implement `create()` methods with proper type casting and array-safe returns.
- For `find()` and similar methods, cast `where` and `order` objects to `any` when generic constraints cause TypeScript errors.
- Maintain consistent ordering and filtering across generic methods.

Decorators and Class Properties

- Do not use `this` inside decorator expressions; instead, use static strings or move dynamic content into the method body.
- When extending base classes, explicitly handle all constructor parameters and pass them to `super()` in the correct order.

Linting and Formatting

- All files must end with a newline character.
- Format complex decorator objects and parameters across multiple lines for readability.
- Follow consistent code formatting for multi-line objects and class definitions.

Entity Inheritance

- Define common fields in abstract base entities with correct TypeORM decorators.
- Use concrete entity classes to extend base entities and map to specific table names.
- Be cautious with eager loading in base entities; prefer conditional loading in concrete implementations.

Generic Service Layer

- Implement reusable generic services extending `BaseService<T>`.
- Always define abstract methods like `getQueryAlias()` for query builder consistency.
- Use `QueryBuilder` with parameterized aliases and proper join conditions for generic date-range and relation queries.

Testing

- Write tests for both generic base classes and concrete implementations.
- Ensure coverage for shared functionality and entity-specific logic.

Build and Compilation

- Before deployment:
- `npm run build` to check TypeScript compilation.
- `npm run lint` and `npm run lint:fix` to ensure code quality.
- `npm run test` to verify functionality.
- Address common compilation errors with:
- Avoiding `this` in decorators.
- Handling `save()` array returns.
- Using `as any` where complex generic constraints break type checks.
- Ensuring EOF newlines.

Performance

- Limit eager loading in base entities to only required relations.
- Use lazy or conditional loading for heavy relations unless always needed.

Maintenance Guidelines

- When adding new concrete implementations:

1. Extend from base classes.
2. Override only necessary methods.
3. Keep naming consistent.
4. Update module imports.
5. Write corresponding tests.

- When changing base classes:
- Assess impact on all inheriting classes.
- Update interfaces if needed.
- Run the full test suite.
- Update documentation.

Refactoring Checklist

- [ ] All files end with newline
- [ ] No `this` references in decorators
- [ ] Type assertions for generic constraints are correct
- [ ] `save()` method handles array returns
- [ ] Abstract methods implemented in concrete classes
- [ ] Module imports updated
- [ ] Build passes without errors
- [ ] All tests pass
- [ ] Linting issues resolved
